///////////////////////////////////////////////////////
// Embarcatech - Instituto do Hardware Br.           //
// Otávio Briske Lima.                               //
// Projeto final: Módulo I2C para rápida             // 
// instrumentação e teste de sensores analógicos.    //
///////////////////////////////////////////////////////


/* 
Objetivo: Realizar a disposição de um plano cartesiano no display OLED, 
correspondente a um gráfico da leitura do sensor analógico pelo tempo.
*/

////////////////////////////
// Adição de bibliotecas: //
////////////////////////////
#include "pico/stdlib.h" // Inclui a biblioteca padrão do Pico, para o uso de recursos de GPIO e de temporizadores.
#include "hardware/i2c.h" // Inclui a biblioteca com funções para facilitar o estabelecimento da comunicação I2C.
#include "inc/ssd1306.h" // Inclui a biblioteca responsável por providenciar ferramentas para a utilização do display OLED.
#include <string.h> // Inclui a biblioteca com ferramentas para manipulação de strings.
#include "hardware/adc.h" // Inclui a biblioteca com ferramentas para o uso do conversor analógico-digital (ADC).

/////////////////////////////////////////////////////
// Definição de constantes e de variáveis globais: //
/////////////////////////////////////////////////////
/*
Abaixo se define duas constantes inteiras para os pinos GPIO
que atuarão como os terminais para comunicação I2C do display OLED:
*/
const uint oled_sda = 14;
const uint oled_scl = 15;

/*
Define segundo a referência [6] o canal em que se encontra o sensor de temperatura:
*/
#define canal_do_adc_do_sensor_de_temperatura_interno 4

/*
Inicialmente se refletiu sobre a possibilidade de utilizar um mapa de bits para a exibição do gráfico,
contudo, pelos testes se constatou que a exibição do gráfico por meio do desenho de linhas é mais rápido,
pois não se faz necessário atualizar todos os pixels do display, abaixo se apresenta a ideia inicial realizada:

A seguir se define um mapa de bits constante, correspondente a imagem de um gráfico na resolução de 128x64 pixels.
A preparação do gráfico foi realizada por meio do software Paint, segundo o processo descrito em [3].
*/
/*
const uint8_t imagem_do_grafico []= {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 
	0x01, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0
};
*/

///////////////////////
// Função principal: //
///////////////////////
int main(){

	/////////////////////////////
	// Configurações iniciais: //
	/////////////////////////////

	/*
	Adiante se configura o canal I2C1 correspondente ao display (segundo as referências [5] e [6])
	com um clock de 400 kHz, pois quanto maior a frequência do clock I2C logo mais rapidamente a 
	comunicação ocorrerá resultando em uma escrita dos dados mais ágil no display.
	Para tanto se considerou [4] que dispõe que a máxima taxa de transferência de dados para o I2C é de
	400 kbits/segundo, implicando na transmissão de 400 kbits de dados/segundo e consequentemente de
	400 kciclos de relógio/segundo.
	Assim o relógio máximo permitido possuiria 400 kHz:
	400 kbits ---- 1 segundo
	1 bit ---- x segundos

	400k.x = 1 ==> x = (400k)^-1 segundos; para o período do relógio, ou:
	400 kHz; para sua frequência.
	*/
    i2c_init(i2c1, 400 * 1000);

	/*
	Abaixo se configura os pinos GPIO do display com o funcionamento
	para comunicação I2C respectivo de cada.
	*/
    gpio_set_function(oled_sda, GPIO_FUNC_I2C);
    gpio_set_function(oled_scl, GPIO_FUNC_I2C);

	/*
	Considerando que as linhas SDA e SCL devem permanecer em nível alto
	ao não serem utilizadas (segundo o protocolo I2C), logo os pinos GPIO correspondentes
	são configurados com resistores de pull-up:
	*/
    gpio_pull_up(oled_sda);
    gpio_pull_up(oled_scl);

    /*
	Realiza a inicialização do display OLED modelo SSD1306:
	*/
    ssd1306_init();

	/*
	Realiza a inicialização do conversor analógico-digital:
	*/
	adc_init();

	/*
	Habilita a utilização do ADC para o sensor de temperatura interno:
	*/
	adc_set_temp_sensor_enabled(true);

	/*
	Seleciona a entrada do ADC como a leitura do sensor de temperatura:
	*/
  	adc_select_input(canal_do_adc_do_sensor_de_temperatura_interno);

	/*
	A seguir se determina uma estrutura que representará a área do
	display utilizada para a exibição de informações.
	Neste contexo se observa que a estrutura é composta por colunas
	(que totalizam 128) e por páginas, as quais por sua vez correspondem
	a 8 linhas cada (conforme pesquisa realizada por meio de [7]); logo
	são definidas 64/8 = 8 páginas (pois o display possui 64 linhas).
	*/
    struct render_area area_do_OLED = {
        start_column : 0, // Define a posição da primeira coluna como 0.
        end_column : ssd1306_width - 1, // Define a posição da última coluna como o número de colunas - 1 (ou seja, 128-1 = 127).
        start_page : 0, // Define a posição da primeira página como 0.
        end_page : ssd1306_n_pages - 1 // Define a posição da última página como o número de páginas - 1 (ou seja, 8-1 = 7).
    };

    /*
	Utilizando a estrutura representativa da área, logo se calcula o tamanho do buffer
	necessário para sua renderização.
	Para o display OLED em questão com dimensões 128x64, logo temos que cada byte do buffer
	corresponderá a uma página, e tendo 64/8 = 8 páginas e 128 colunas, então o comprimento
	será de 128*8 = 1024 bytes (pois cada coluna corresponde a 1 bit e cada página a 8 bits).
	*/
	calculate_render_area_buffer_length(&area_do_OLED);

	/*
	Com o objetivo de se zerar o display, logo inicialmente se cria uma lista de bytes
	(buffer) com o comprimento do buffer:
	*/
	uint8_t buffer[ssd1306_buffer_length];
	/*
	Então se seta suas posições de memória com valores nulos,
	que são por fim exibidos no display (de forma com que nada seja nele representado).
	*/
	memset(buffer, 0, ssd1306_buffer_length);
	render_on_display(buffer, &area_do_OLED);

	/*
	Abaixo se configura o display e se exibe o gráfico desejado nele (segundo a concepção anterior do bitmap):
	*/
	/*
	ssd1306_t display_OLED; // Define uma variável correspondente ao display OLED.
	ssd1306_init_bm(&display_OLED, 128, 64, false, 0x3C, i2c1); // Inicia o display com a informação de suas dimensões e de que possuirá comunicação I2C pelo canal i2c1.
	ssd1306_config(&display_OLED); // Realiza outras configurações necessárias no display.
	ssd1306_draw_bitmap(&display_OLED, imagem_do_grafico); // Carrega no display o gráfico em formato de mapa de bits.
	*/

	/*
	A seguir se realiza o processo de geração do gráfico através da exibição de
	múltiplas linhas (pelo algoritmo de Bresenham), o qual ocorre mais rapidamente que o uso de um
	mapa de bits para mesma função.
	Durante este período se passa inicialmente as coordenadas (x,y) dos pontos iniciais e então a dos 
	pontos finais, de forma com que o algoritmo de Bresenham determine os pixels que devem ser acesos
	(informado por "true") para compor o segmento entre esses pontos.
	Por fim se renderiza o display, exibindo as linhas solicitadas.
	*/
	ssd1306_draw_line(buffer, 0, 0, 0, 63, true);
	ssd1306_draw_line(buffer, 0, 63, 127, 63, true);
	ssd1306_draw_line(buffer, 1, 0, 2, 0, true);
	ssd1306_draw_line(buffer, 1, 15, 2, 15, true);
	ssd1306_draw_line(buffer, 1, 31, 2, 31, true);
	ssd1306_draw_line(buffer, 1, 47, 2, 47, true);
	// ssd1306_draw_line(buffer, 1, 63, 2, 63, true);
	ssd1306_draw_line(buffer, 127, 61, 127, 62, true);
	ssd1306_draw_line(buffer, 111, 61, 111, 62, true);
	ssd1306_draw_line(buffer, 95, 61, 95, 62, true);
	ssd1306_draw_line(buffer, 79, 61, 79, 62, true);
	ssd1306_draw_line(buffer, 63, 61, 63, 62, true);
	ssd1306_draw_line(buffer, 47, 61, 47, 62, true);
	ssd1306_draw_line(buffer, 31, 61, 31, 62, true);
	ssd1306_draw_line(buffer, 15, 61, 15, 62, true);
	// ssd1306_draw_line(buffer, 0, 61, 0, 62, true);
	render_on_display(buffer, &area_do_OLED);

	while(true){ // Loop infinito para constante execução das instruções internas a ele:

		/*
		Realiza uma única conversão e retorna o valor à variável associada.
		*/
		uint16_t leitura_do_sensor;
		leitura_do_sensor = adc_read();

		/*
		Sendo a leitura do ADC um número entre 0 e 4095 (dado a resolução de 12 bits do ADC), 
		logo para associarmos o valor lido à uma linha do display para exibição definimos a 
		linha correspondente como: (leitura do sensor/leitura máxima)*64.
		*/
		uint16_t linha_correspondente_a_leitura;
		linha_correspondente_a_leitura = (leitura_do_sensor*64)/4096;

		/*
		Abaixo se utiliza a variável i para criar uma linha de 4 pixels para cada leitura ao ela ser 
		exibida no display:
		*/
		static int i = 0; // Define uma variável estática inteira, cujo valor indicará os pontos no display.
		ssd1306_draw_line(buffer, i, linha_correspondente_a_leitura, i+3, linha_correspondente_a_leitura, true);
		render_on_display(buffer, &area_do_OLED);
		sleep_ms(500); // Realiza a espera de um intervalo de tempo de 500 ms entre cada medida e exibição.
		i=i+4; // Atualiza a variável i para obter a posição das colunas da próxima leitura.

		if(i>124){ // Caso as colunas tenham sido finalizadas:

			i = 0; // Recomeça o valor de i.
			
			/*
			Zera o display:
			*/
			memset(buffer, 0, ssd1306_buffer_length);
			render_on_display(buffer, &area_do_OLED);

			/*
			Refaz o gráfico:
			*/
			ssd1306_draw_line(buffer, 0, 0, 0, 63, true);
			ssd1306_draw_line(buffer, 0, 63, 127, 63, true);
			ssd1306_draw_line(buffer, 1, 0, 2, 0, true);
			ssd1306_draw_line(buffer, 1, 15, 2, 15, true);
			ssd1306_draw_line(buffer, 1, 31, 2, 31, true);
			ssd1306_draw_line(buffer, 1, 47, 2, 47, true);
			// ssd1306_draw_line(buffer, 1, 63, 2, 63, true);
			ssd1306_draw_line(buffer, 127, 61, 127, 62, true);
			ssd1306_draw_line(buffer, 111, 61, 111, 62, true);
			ssd1306_draw_line(buffer, 95, 61, 95, 62, true);
			ssd1306_draw_line(buffer, 79, 61, 79, 62, true);
			ssd1306_draw_line(buffer, 63, 61, 63, 62, true);
			ssd1306_draw_line(buffer, 47, 61, 47, 62, true);
			ssd1306_draw_line(buffer, 31, 61, 31, 62, true);
			ssd1306_draw_line(buffer, 15, 61, 15, 62, true);
			// ssd1306_draw_line(buffer, 0, 61, 0, 62, true);
			render_on_display(buffer, &area_do_OLED);
		}
	}
	return 0; // Realiza um retorno indicando que o programa foi concluído com êxito o qual, contudo, nunca deverá ocorrer.
}

//////////////////
// Referências: //
//////////////////

// [1] Curso de capacitação EMBARCATECH, Tarefa 1 - Unidade 4 - Cap. 5, Exercício 6.

// [2] "imbaTIMvel", timoteo_altoe. “BitDogLab-C/Display_oled at Main · BitDogLab/BitDogLab-C.” GitHub, 2024, github.com/BitDogLab/BitDogLab-C/tree/main/display_oled. Accessed 17 Feb. 2025.

// [3] Elivelton Moura. “Exibindo Imagens No Display OLED Da BitDogLab.” YouTube, 25 Jan. 2025, www.youtube.com/watch?v=goGr8w9YaVc. Accessed 17 Feb. 2025.

// [4] Curso de capacitação EMBARCATECH, Capitulo 6 - Guia de Interfaces de Comunicação com RP2040 / Raspberry Pi Pico W, 18.37M2 - U4C6O12E - Ebook.pdf.

// [5] piconafonseca. “Organização Dos Pinos Da BitDogLab.” Scribd, 2025, pt.scribd.com/document/814073680/Organizacao-dos-Pinos-da-BitDogLab. Accessed 17 Feb. 2025.

// [6] “Raspberry Pi Pico W GPIO Pinout.” Pinout.xyz, 2025, https://picow.pinout.xyz. Accessed 17 Feb. 2025.

// [7] “DeepSeek.” Deepseek.com, 2025, https://chat.deepseek.com.